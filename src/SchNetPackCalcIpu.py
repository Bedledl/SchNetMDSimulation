from typing import Union, List, Dict

import poptorch

from schnetpack.md import System
from schnetpack.md.calculators import SchNetPackCalculator
from schnetpack.md.neighborlist_md import NeighborListMD


class SchNetPackCalcIpu(SchNetPackCalculator):
    def __init__(
            self,
            model_file: str,
            force_key: str,
            energy_unit: Union[str, float],
            position_unit: Union[str, float],
            neighbor_list: NeighborListMD,
            energy_key: str = None,
            stress_key: str = None,
            required_properties: List = [],
            property_conversion: Dict[str, Union[str, float]] = {},
            script_model: bool = False,
    ):
        super(SchNetPackCalcIpu, self).__init__(
            model_file,
            force_key,
            energy_unit,
            position_unit,
            neighbor_list,
            energy_key,
            stress_key,
            required_properties,
            property_conversion,
            script_model
        )

        self.ipu_executor = poptorch.inferenceModel(self.model)

    def calculate(self, system: System):
        """
        Main routine, generates a properly formatted input for the schnetpack model from the system, performs the
        computation and uses the results to update the system state.

        This method overwrites the SchNetPackCalculator Method with the exact same logic,
        except, that the inference is calculated by calling the PoplarExecutor, generated by pytorch.inferenceModel.
        In this way the inference is calculated on the IPU instead of the CPU.

        Args:
            system (schnetpack.md.System): System object containing current state of the simulation.
        """
        inputs = self._generate_input(system)
        self.results = self.ipu_executor(inputs)
        self._update_system(system)
