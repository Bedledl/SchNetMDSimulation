from typing import Union, List, Dict

from schnetpack.properties import idx_i, idx_j, offsets

import poptorch
import torch

from schnetpack.md import System
from schnetpack.md.calculators import SchNetPackCalculator
from schnetpack.md.neighborlist_md import NeighborListMD

from datetime import datetime


class SchNetPackCalcIpu(SchNetPackCalculator):
    def __init__(
            self,
            model_file: str,
            force_key: str,
            energy_unit: Union[str, float],
            position_unit: Union[str, float],
            neighbor_list: NeighborListMD,
            energy_key: str = None,
            stress_key: str = None,
            required_properties: List = [],
            property_conversion: Dict[str, Union[str, float]] = {},
            script_model: bool = False,
    ):
        super(SchNetPackCalcIpu, self).__init__(
            model_file,
            force_key,
            energy_unit,
            position_unit,
            neighbor_list,
            energy_key,
            stress_key,
            required_properties,
            property_conversion,
            script_model
        )

        self.model.eval()
        t = datetime.now()
        self.d = t - t
        self.d_neighborlist = t - t
        self.steps = 0
        self.ipu_executor = poptorch.inferenceModel(self.model)
        self.compiled = False
        n_atoms = 9
        self.idx_i = torch.arange(n_atoms).repeat_interleave(n_atoms)
        self.idx_j = torch.arange(n_atoms).repeat(n_atoms)
        self.offsets = torch.tensor([[0, 0, 0]]).repeat(n_atoms * n_atoms, 1)

    def calculate(self, system: System):
        """
        Main routine, generates a properly formatted input for the schnetpack model from the system, performs the
        computation and uses the results to update the system state.

        This method overwrites the SchNetPackCalculator Method with the exact same logic,
        except, that the inference is calculated by calling the PoplarExecutor, generated by pytorch.inferenceModel.
        In this way the inference is calculated on the IPU instead of the CPU.

        Args:
            system (schnetpack.md.System): System object containing current state of the simulation.
        """
        inputs = self._generate_input(system)
        a = datetime.now()
        self.results = self.ipu_executor(inputs)
        b = datetime.now()
        self.d += b-a
        self.steps += 1
        self._update_system(system)

    def _generate_input(self, system: System) -> Dict[str, torch.Tensor]:
        """
        Function to extracts neighbor lists, atom_types, positions e.t.c. from the system and generate a properly
        formatted input for the schnetpack model.

        Args:
            system (schnetpack.md.System): System object containing current state of the simulation.

        Returns:
            dict(torch.Tensor): Schnetpack inputs in dictionary format.
        """
        inputs = self._get_system_molecules(system)
        a = datetime.now()
        neighbors = {
            idx_i: self.idx_i,
            idx_j: self.idx_j,
            offsets: self.offsets
        }
        #neighbors = self.neighbor_list.get_neighbors(inputs)
        b = datetime.now()
        self.d_neighborlist += b - a
        inputs.update(neighbors)
        return inputs
